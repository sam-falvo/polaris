[
 [module PolarisDecoder
  &input [
   [ir "[31:0]"]
   reset ft0 ft1
   xt0 xt1 xt2 xt3 xt4
   iack_i dack_i
   Zflag Cflag NxorVflag
  ]
  &output [
   alua_0 alua_ia alua_imm12i alua_imm12s alua_rf
   alub_disp13sb alub_imm12i alub_imm20u alub_rf
   dcyc_1 ddat_rf dptr_alu dsigned [dsize "[1:0]"] dwe_1
   ft0_1 ft1_1
   iadr_pc ia_pc icyc_1
   ir_idat ir_reset ir_tir
   pc_alu pc_pc_plus_4 pc_reset pc_mtvec pc_mepc
   rfa_ir1 rfa_ir2 rfa_ird rf_alu rfwe
   tir_idat
   xt0_1 xt1_1 xt2_1 xt3_1 xt4_1
   mepc_pc mpie_mie mie_0 mie_mpie mpie_1
   mcause_3 mcause_11
  ]
  &wire [
   fn3_eq_0 fn3_eq_1 fn3_eq_2 fn3_eq_3 fn3_eq_4 fn3_eq_5 fn3_eq_6 fn3_eq_7
   isBranch isEBreak isECall isJAL isJALR isLoad isLuiAuipc isMem isStore isOp
   isMRET isSFENCE_VM isWFI
   prefetch
   useAlu
  ]
 ]

 [on [["ir[14:12]" 3'b000]]	fn3_eq_0]
 [on [["ir[14:12]" 3'b001]]	fn3_eq_1]
 [on [["ir[14:12]" 3'b010]]	fn3_eq_2]
 [on [["ir[14:12]" 3'b011]]	fn3_eq_3]
 [on [["ir[14:12]" 3'b100]]	fn3_eq_4]
 [on [["ir[14:12]" 3'b101]]	fn3_eq_5]
 [on [["ir[14:12]" 3'b110]]	fn3_eq_6]
 [on [["ir[14:12]" 3'b111]]	fn3_eq_7]

 [on [["ir[6:0]" 7'b0000011]]			isLoad]
 [on [["ir[6:0]" 7'b0100011]]			isStore]
  \\ OP, OP-IMM, OP-32, and OP-IMM-32 are all basically the same.
  \\ IR[5] IR[3]
  \\   0     0    OP-IMM
  \\   0     1    OP-IMM-32
  \\   1     0    OP
  \\   1     1    OP-32
 [on ["~ir[6]" "ir[4:0]" ["ir[2:0]" 3'b011]]	isOp]
  \\ LUI and AUIPC
  \\ IR[5]
  \\   0   AUIPC
  \\   1   LUI
 [on ["~ir[6]" ["ir[4:0]" 5'b10111]]		isLuiAuipc]
 [on [["ir[6:0]" 7'b1100011]]			isBranch]
 [on [["ir[6:0]" 7'b1100111]]			isJALR]
 [on [["ir[6:0]" 7'b1101111]]			isJAL]
 [on [["ir[31:28]" 4'h0]
      ["ir[19:0]" 20'h0000F]]			isMem]	\\ FENCE
 [on [["ir[31:0]" 32'h0000100F]]		isMem]	\\ FENCE.I
 [on [["ir[31:21]" 11'h000]
      ["ir[19:0]"  20'h00073]]			isECallBreak]
 [on [["ir[31:0]" 32'h30200073]]		isMRET]
 [on [["ir[31:0]" 32'h10500073]]		isWFI]
 [on [["ir[31:0]" 32'h10400073]]		isSFENCE_VM]

 \\ Power-on reset logic.

 [on [reset]				ir_reset pc_reset ft0_1]


 \\ Instruction fetch logic.  Instructions will (at some point in time) kick
 \\ off instruction fetch by asserting ft0.  The prefetch signal affects
 \\ whether or not we reload and start new instruction execution right away, or
 \\ if we wait until the current instruction explicitly decides to let us go.

 [on [~reset ft0 ~iack_i]		iadr_pc icyc_1 ft0_1]
 [on [~reset ft0 iack_i ~prefetch]	iadr_pc	icyc_1       ir_idat ia_pc pc_pc_plus_4 xt0_1]
 [on [~reset ft0 iack_i prefetch]	iadr_pc	icyc_1       tir_idat ft1_1]
 [on [~reset ft1 prefetch]		ft1_1]
 [on [~reset ft1 ~prefetch]		ir_tir ia_pc pc_pc_plus_4 xt0_1]
 [on [~reset "~{ft0,ft1}" "~{xt0,xt1,xt2,xt3,xt4,xt5}"]
 	ft0_1 mepc_pc pc_mtvec mpie_mie mie_0 mcause_2]

 \\ LOADs

 [on [~reset xt0 isLoad]		prefetch ft0_1 rfa_ir1 xt1_1]
 [on [~reset xt1 isLoad]		prefetch alub_rf alua_imm12i xt2_1]
 [on [~reset xt2 isLoad]		prefetch alufn_sum_en dptr_alu xt3_1]

     \\ Unsigned loads 

 [on [~reset xt3 "~ir[14]" isLoad ~dack_i]
		prefetch [dsize "ir[13:12]"] dcyc_1 rfa_ird rfwe xt3_1]
 [on [~reset xt3 "~ir[14]" ["ir[6:0]" 7'b0000011] dack_i]
 		[dsize "ir[13:12]"] dcyc_1 rfa_ird rfwe]

    \\ Signed loads

 [on [~reset xt3 "ir[14]" isLoad ~dack_i]
		prefetch dsigned [dsize "ir[13:12]"] dcyc_1 rfa_ird rfwe xt3_1]
 [on [~reset xt3 "ir[14]" isLoad dack_i]
 		dsigned [dsize "ir[13:12]"] dcyc_1 rfa_ird rfwe]

 \\ STOREs

 [on [~reset xt0 isStore]		prefetch ft0_1 rfa_ir1 xt1_1]
 [on [~reset xt1 isStore]		prefetch alub_rf alua_imm12s xt2_1]
 [on [~reset xt2 isStore]		prefetch alufn_sum_en dptr_alu rfa_ir2 xt3_1]
 [on [~reset xt3 isStore "~ir[14]" ~dack_i]
		prefetch [dsize "ir[13:12]"] dcyc_1 dwe_1 ddat_rf rfa_ir2 xt3_1]
 [on [~reset xt3 isStore "~ir[14]" dack_i]
		[dsize "ir[13:12]"] dcyc_1 dwe_1 ddat_rf]

 \\ OPs (OP, OP-IMM, OP-32, OP-IMM-32)
 [on [~reset xt0 isOp]			ft0_1 xt1_1	rfa_ir1]
 [on [~reset xt1 isOp]			xt2_1		rfa_ir2 alua_rf]
 [on [~reset xt2 isOp "ir[5]"]		xt3_1		alub_rf]
 [on [~reset xt2 isOp "~ir[5]"]		xt3_1		alub_imm12i]
 [on [~reset xt3 isOp "~ir[3]"]				rfa_ird rf_alu rfwe useAlu]
 [on [~reset xt3 isOp "ir[3]"]				rfa_ird rf_alu rfwe useAlu alufn_sx32_en]

 [on [~reset useAlu fn3_eq_0]				alufn_sum_en]
 [on [~reset useAlu fn3_eq_1]				alufn_lsh_en]
 [on [~reset useAlu fn3_eq_2]				alufn_carry_1 alufn_invB_1 alufn_lts_en]
 [on [~reset useAlu fn3_eq_3]				alufn_carry_1 alufn_invB_1 alufn_ltu_en]
 [on [~reset useAlu fn3_eq_4]				alufn_xor_en]
 [on [~reset useAlu fn3_eq_5 "~ir[30]"]			alufn_rsh_en]
 [on [~reset useAlu fn3_eq_5 "ir[30]"]			alufn_rsh_en alufn_carry_1]
 [on [~reset useAlu fn3_eq_6]				alufn_and_en alufn_xor_en]
 [on [~reset useAlu fn3_eq_7]				alufn_and_en]

 \\ LUI, AUIPC
 [on [~reset xt0 isLuiAuipc "ir[5]"]	ft0_1 xt1_1	alua_0]
 [on [~reset xt0 isLuiAuipc "~ir[5]"]	ft0_1 xt1_1	alua_ia]
 [on [~reset xt1 isLuiAuipc]		xt2_1		alub_imm20u]
 [on [~reset xt2 isLuiAuipc]				alufn_sum_en rfa_ird rf_alu rfwe]

 \\ Bcc
 [on [~reset xt0 isBranch]		xt1_1	rfa_ir1]
 [on [~reset xt1 isBranch]		xt2_1	rfa_ir2  alua_rf]
 [on [~reset xt2 isBranch]		xt3_1            alub_rf]
 [on [~reset xt3 isBranch]			alufn_sum_en alufn_invB_1 alufn_carry_1]

   \\ BEQ
 [on [~reset xt3 isBranch fn3_eq_0 ~Zflag]		ft0_1]
 [on [~reset xt3 isBranch fn3_eq_0 Zflag]		xt4_1	alua_ia alub_disp13sb]

   \\ BNE
 [on [~reset xt3 isBranch fn3_eq_1 ~Zflag]		xt4_1	alua_ia alub_disp13sb]
 [on [~reset xt3 isBranch fn3_eq_1 Zflag]		ft0_1]

   \\ BLT
 [on [~reset xt3 isBranch fn3_eq_4 ~NxorVflag]		ft0_1]
 [on [~reset xt3 isBranch fn3_eq_4 NxorVflag]		xt4_1	alua_ia alub_disp13sb]

   \\ BGE
 [on [~reset xt3 isBranch fn3_eq_5 ~NxorVflag]		xt4_1	alua_ia alub_disp13sb]
 [on [~reset xt3 isBranch fn3_eq_5 NxorVflag]		ft0_1]

   \\ BLTU
 [on [~reset xt3 isBranch fn3_eq_6 Cflag]		ft0_1]
 [on [~reset xt3 isBranch fn3_eq_6 Zflag]		ft0_1]
 [on [~reset xt3 isBranch fn3_eq_6 ~Cflag ~ZFlag]	xt4_1	alua_ia alub_disp13sb]

   \\ BGEU
 [on [~reset xt3 isBranch fn3_eq_7 Cflag]		xt4_1	alua_ia alub_disp13sb]
 [on [~reset xt3 isBranch fn3_eq_7 Zflag]		xt4_1	alua_ia alub_disp13sb]
 [on [~reset xt3 isBranch fn3_eq_7 ~Cflag ~ZFlag]	ft0_1]

 [on [~reset xt4 isBranch]		ft0_1	pc_alu alufn_sum_en]

 \\ JALR
 [on [~reset xt0 isJALR]		xt1_1	rfa_ird rf_pc rfwe]
 [on [~reset xt1 isJALR]		xt2_1	rfa_ir1]
 [on [~reset xt2 isJALR]		xt3_1	alua_rf alub_imm12i]
 [on [~reset xt3 isJALR]			alufn_sum_en pc_alu ft0_1]

 \\ JAL
 [on [~reset xt0 isJAL]			xt1_1	rfa_ird rf_pc rfwe]
 [on [~reset xt1 isJAL]			xt2_1	alua_ia alub_disp21]
 [on [~reset xt2 isJAL]			alufn_sum_en pc_alu ft0_1]

 \\ FENCE and FENCE.I -- these are NOPs for Polaris, since we have no caches and no
 \\ multi-CPU support.
 [on [~reset xt0 isMem]			ft0_1]

 \\ ECALL, EBREAK, MRET
 [on [~reset xt0 isECallBreak]		ft0_1 mepc_pc pc_mtvec mpie_mie mie_0]
 [on [~reset xt0 isECallBreak "~ir[20]"]  mcause_11]
 [on [~reset xt0 isECallBreak "ir[20]"]   mcause_3]

 [on [~reset xt0 isMRET]		ft0_1 pc_mepc mie_mpie mpie_1]

 \\ WFI -- NOP for now.
 [on [~reset xt0 isWFI]			ft0_1]

 \\ SFENCE.VM
 [on [~reset xt0 isSFENCE_VM]		ft0_1]
]

